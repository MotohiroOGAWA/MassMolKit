import os
from pathlib import Path
from typing import Tuple, List, Dict, Any, Type, Set, Iterable, Optional
from dataclasses import dataclass
import itertools
from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit.Chem import rdChemReactions
from bidict import bidict
import re
import json
import inspect
import yaml

from ..chem.Compound import Compound
from .FragmentResult import FragmentResult, FragmentProduct

class RuleBase:
    RULE_TYPE: str = "rule_base"

    def to_dict(self) -> Dict[str, Any]:
        raise NotImplementedError

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "RuleBase":
        raise NotImplementedError

class BondUnsaturationRule(RuleBase):
    RULE_TYPE = "bond_unsaturation"

    def __init__(self, max_count: int):
        assert max_count >= 0, "max_count must be non-negative"
        assert isinstance(max_count, int), "max_count must be an integer"
        self.max_count = max_count
        self.delta_h_step = -2
        self.smarts = "[*;!H0]-[*;!H0]"
        self.pat = Chem.MolFromSmarts(self.smarts)

    @property
    def num_candidates(self) -> int:
        """
        Total number of ΔH candidates (including 0).
        """
        return self.max_count + 1

    @property
    def delta_h_candidates(self) -> Tuple[int, ...]:
        """
        All possible ΔH values generated by this rule,
        regardless of applicability to a specific compound.
        """
        return tuple(i * self.delta_h_step for i in range(self.num_candidates))

    def evaluate(self, compound: Compound) -> Tuple[bool, ...]:
        """
        Return a boolean mask indicating which ΔH candidates
        are applicable to the given compound.

        The mask has the same length as delta_h_candidates.
        """
        match_count = len(compound._mol.GetSubstructMatches(self.pat))
        applicable_count = min(match_count, self.max_count)

        applicability_mask = tuple(
            i <= applicable_count for i in range(self.num_candidates)
        )
        return applicability_mask
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "max_count": self.max_count,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "BondUnsaturationRule":
        return cls(max_count=int(data["max_count"]))
    
class RadicalRule(RuleBase):
    RULE_TYPE = "radical"

    def __init__(self, max_count: int = 1):
        assert max_count >= 0, "max_count must be non-negative"
        assert isinstance(max_count, int), "max_count must be an integer"
        self.max_count = max_count
        self.delta_h = 0
        self.smarts = "[*;!H0]"   # any atom with at least one hydrogen
        self.pat = Chem.MolFromSmarts(self.smarts)

    @property
    def num_candidates(self) -> int:
        """
        Total number of ΔH candidates (including 0).
        """
        return self.max_count + 1

    @property
    def delta_h_candidates(self) -> Tuple[int, ...]:
        """
        All possible ΔH values generated by this rule,
        regardless of applicability to a specific compound.
        """
        return tuple(-i for i in range(self.num_candidates))

    def evaluate(self, compound: Compound) -> Tuple[bool, ...]:
        """
        Return a boolean mask indicating which ΔH candidates
        are applicable to the given compound.

        The mask has the same length as delta_h_candidates.
        """
        match_count = len(compound._mol.GetSubstructMatches(self.pat))
        applicable_count = min(match_count, self.max_count)

        applicability_mask = tuple(
            i <= applicable_count for i in range(self.num_candidates)
        )
        return applicability_mask
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "max_count": self.max_count,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "RadicalRule":
        return cls(max_count=int(data.get("max_count", 1)))

class IonHydrogenShiftRule(RuleBase):
    RULE_TYPE = "ion_hydrogen_shift"

    def __init__(
        self,
        plus_h_atoms: Iterable[str],
        minus_h_atoms: Iterable[str],
    ):
        self.plus_h_atoms: Tuple[str, ...] = tuple(dict.fromkeys(plus_h_atoms))
        self.minus_h_atoms: Tuple[str, ...] = tuple(dict.fromkeys(minus_h_atoms))

        # Build SMARTS (atomic-number style) and pats
        self.plus_smarts, self.plus_pat = self._build_smarts_and_pat(self.plus_h_atoms, label="plus")
        self.minus_smarts, self.minus_pat = self._build_smarts_and_pat(self.minus_h_atoms, label="minus")

    @property
    def num_candidates(self) -> int:
        return 3

    @property
    def delta_h_candidates(self) -> Tuple[int, int, int]:
        return (self.minus_delta_h, self.neutral_delta_h, self.plus_delta_h)
    
    @property
    def plus_delta_h(self) -> int:
        return 1
    @property
    def minus_delta_h(self) -> int:
        return -1
    @property
    def neutral_delta_h(self) -> int:
        return 0

    def evaluate(self, compound: Compound) -> Tuple[int, ...]:
        mol = compound._mol

        applicability_mask = [False, False, False]
        delta_h_candidates = self.delta_h_candidates

        if(compound.charge == 0):
            if mol.HasSubstructMatch(self.minus_pat):
                applicability_mask[delta_h_candidates.index(self.minus_delta_h)] = True

            if mol.HasSubstructMatch(self.plus_pat):
                applicability_mask[delta_h_candidates.index(self.plus_delta_h)] = True
        else:
            # For charged compounds, only allow neutral shift
            applicability_mask[delta_h_candidates.index(self.neutral_delta_h)] = True

        return tuple(applicability_mask)

    @staticmethod
    def _build_smarts_and_pat(symbols: Set[str], *, label: str):
        """
        symbols: e.g. {"P","S","N","O"}
        returns: (smarts, pat)
        raises: ValueError if invalid symbols or SMARTS cannot be parsed
        """
        if not symbols:
            # Empty set means "no applicable atoms" -> you can choose to allow it,
            # but making a pattern for it is usually meaningless.
            raise ValueError(f"{label}_h_atoms is empty; cannot build SMARTS/pat.")

        # Convert element symbols to atomic numbers
        nums = []
        for sym in symbols:
            try:
                num = Chem.Atom(sym).GetAtomicNum()
            except Exception as e:
                raise ValueError(f"Invalid element symbol in {label}_h_atoms: '{sym}'") from e
            if num <= 0:
                raise ValueError(f"Invalid element symbol in {label}_h_atoms: '{sym}'")
            nums.append(num)

        nums = sorted(set(nums))
        smarts = "[" + ",".join(f"#{n}" for n in nums) + "]"  # e.g. [#6,#15,#16]

        pat = Chem.MolFromSmarts(smarts)
        if pat is None:
            raise ValueError(f"Failed to parse SMARTS for {label}: {smarts}")

        return smarts, pat
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "plus_h_atoms": sorted(self.plus_h_atoms),
            "minus_h_atoms": sorted(self.minus_h_atoms),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "IonHydrogenShiftRule":
        return cls(
            plus_h_atoms=data.get("plus_h_atoms", []),
            minus_h_atoms=data.get("minus_h_atoms", []),
        )
    

_RULE_TYPE_TO_CLS: Dict[str, Type[RuleBase]] = {
    BondUnsaturationRule.RULE_TYPE: BondUnsaturationRule,
    RadicalRule.RULE_TYPE: RadicalRule,
    IonHydrogenShiftRule.RULE_TYPE: IonHydrogenShiftRule,
}

class HydrogenRearrangement:
    def __init__(self, ion_shift_rule: Optional[IonHydrogenShiftRule] = None, radical_rule: Optional[RadicalRule] = None, bond_unsaturation_rule: Optional[BondUnsaturationRule] = None):
        self.version = 1.0
        self.ion_shift_rule = ion_shift_rule
        self.radical_rule = radical_rule
        self.bond_unsaturation_rule = bond_unsaturation_rule

    @property
    def num_delta_h_candidates(self) -> Dict[str, int]:
        """
        Return the number of ΔH candidates for each rule as a dict.

        Example:
          {
            "ion_shift": 2,
            "radical": 2,
            "bond_unsaturation": 3
          }
        """
        counts: Dict[str, int] = {}

        if self.ion_shift_rule is not None:
            counts["ion_shift"] = self.ion_shift_rule.num_candidates

        if self.radical_rule is not None:
            counts["radical"] = self.radical_rule.num_candidates

        if self.bond_unsaturation_rule is not None:
            counts["bond_unsaturation"] = self.bond_unsaturation_rule.num_candidates

        return counts

    @property
    def delta_h_candidates(self) -> Dict[str, Tuple[int, ...]]:
        """
        Return ΔH candidate values for each rule as a dict.

        Example:
          {
            "ion_shift": (-1, +1),
            "radical": (0, -1, ...),
            "bond_unsaturation": (0, -2, -4, ...)
          }
        """
        candidates: Dict[str, Tuple[int, ...]] = {}

        if self.ion_shift_rule is not None:
            candidates["ion_shift"] = tuple(self.ion_shift_rule.delta_h_candidates)

        if self.radical_rule is not None:
            candidates["radical"] = tuple(self.radical_rule.delta_h_candidates)

        if self.bond_unsaturation_rule is not None:
            candidates["bond_unsaturation"] = tuple(self.bond_unsaturation_rule.delta_h_candidates)

        return candidates

    @property
    def neutral_total_dh_candidates(self) -> Tuple[int, ...]:
        """
        Return all possible total ΔH values generated by neutral
        hydrogen rearrangement rules, independent of compound evaluation.

        Ion shift rule is NOT included.

        Example:
            (-3, -2, -1, 0)
        """

        # Collect neutral rule candidate lists (exclude ion_shift)
        per_rule_candidates = []

        if self.radical_rule is not None:
            per_rule_candidates.append(self.radical_rule.delta_h_candidates)

        if self.bond_unsaturation_rule is not None:
            per_rule_candidates.append(self.bond_unsaturation_rule.delta_h_candidates)

        # If no neutral rules exist, return empty tuple
        if len(per_rule_candidates) == 0:
            return tuple()

        # Compute Cartesian product across rules
        total_dh = {
            int(sum(combo))
            for combo in itertools.product(*per_rule_candidates)
        }

        return tuple(sorted(total_dh))
    
    def evaluate(self, compound: Compound) -> Dict[str, Tuple[bool, ...]]:
        """
        Evaluate the applicability of ΔH candidates for each rule on the given compound.

        Returns a dict mapping rule names to boolean masks.

        Example:
          {
            "ion_shift": (True, False),
            "radical": (True, True, False),
            "bond_unsaturation": (True, True, True, False)
          }
        """
        applicability: Dict[str, Tuple[bool, ...]] = {}

        if self.ion_shift_rule is not None:
            applicability["ion_shift"] = self.ion_shift_rule.evaluate(compound)

        if self.radical_rule is not None:
            applicability["radical"] = self.radical_rule.evaluate(compound)

        if self.bond_unsaturation_rule is not None:
            applicability["bond_unsaturation"] = self.bond_unsaturation_rule.evaluate(compound)

        return applicability

    def copy(self) -> 'HydrogenRearrangement':
        sig = inspect.signature(self.__init__)
        init_args = [p.name for p in sig.parameters.values() if p.name != "self"]

        kwargs = {arg: getattr(self, arg) for arg in init_args if hasattr(self, arg)}

        return self.__class__(**kwargs)
    
    def to_dict(self) -> Dict[str, Any]:
        """
        Serialize as plain dict (YAML/JSON safe).
        """
        return {
            "version": getattr(self, "version", 1.0),
            IonHydrogenShiftRule.RULE_TYPE: None if self.ion_shift_rule is None else self.ion_shift_rule.to_dict(),
            RadicalRule.RULE_TYPE: None if self.radical_rule is None else self.radical_rule.to_dict(),
            BondUnsaturationRule.RULE_TYPE: None if self.bond_unsaturation_rule is None else self.bond_unsaturation_rule.to_dict(),
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "HydrogenRearrangement":
        def _load_rule(rule_data: Optional[Dict[str, Any]], t: str) -> Optional[RuleBase]:
            if rule_data is None:
                return None
            if t not in _RULE_TYPE_TO_CLS:
                raise ValueError(f"Unknown rule type: {t}")
            return _RULE_TYPE_TO_CLS[t].from_dict(rule_data)

        obj = cls(
            ion_shift_rule=_load_rule(data.get(IonHydrogenShiftRule.RULE_TYPE), IonHydrogenShiftRule.RULE_TYPE),  # type: ignore
            radical_rule=_load_rule(data.get(RadicalRule.RULE_TYPE), RadicalRule.RULE_TYPE),      # type: ignore
            bond_unsaturation_rule=_load_rule(data.get(BondUnsaturationRule.RULE_TYPE), BondUnsaturationRule.RULE_TYPE),  # type: ignore
        )
        if "version" in data:
            obj.version = data["version"]
        return obj

    def to_yaml(self, path: str):
        with open(path, "w", encoding="utf-8") as f:
            yaml.safe_dump(self.to_dict(), f, sort_keys=False, allow_unicode=True)

    @classmethod
    def from_yaml(cls, path: str) -> "HydrogenRearrangement":
        with open(path, "r", encoding="utf-8") as f:
            data = yaml.safe_load(f)
        if not isinstance(data, dict):
            raise ValueError("YAML root must be a mapping (dict).")
        return cls.from_dict(data)
    
    @staticmethod
    def load_default_positive() -> "HydrogenRearrangement":
        """Load the default positive ion mode cleavage pattern set."""
        file_path = os.path.join(Path(__file__).parent.parent, "fragment", "hydrogen_rearrangements", "pos", "default.yaml")
        return HydrogenRearrangement.from_yaml(file_path)
    
